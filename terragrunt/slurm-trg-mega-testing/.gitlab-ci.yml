---

workflow:
  rules:
    # Мы запускаем данный пайплайн для PR созданных против ветки Main
    - if: '$CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $CI_DEFAULT_BRANCH'
      variables:
        STAGING_PLAN: 'true'
    #  Мы запускаем данный пайплайн по событиям с веткой Main
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH'
      variables:
        STAGING_PLAN: 'true'
        STAGING_APPLY: 'true'
    # Мы запускаем данный пайплайн по событиям с тегами
    - if: '$CI_COMMIT_TAG =~ /^v.*/'
      variables:
        PRODUCTION_PLAN: 'true'
        PRODUCTION_APPLY: 'true'
        RUN_TESTS: 'false'
    # Мы запускаем данный пайплайн по событиям запуска через UI
    - if: '$CI_PIPELINE_SOURCE == "web"'
      variables:
        STAGING_APPLY: 'true'
        PRODUCTION_APPLY: 'true'
# Это набор переменных, используемых по умолчанию
variables:
  # Дополнительные переменные
  TF_GITLAB_BACKEND_ADDRESS: 'https://gitlab.slurm.io/api/v4/projects/${CI_PROJECT_ID}/terraform/state'
  ## Указывает папку для сохранения всех провайдеров
  TF_PLUGIN_CACHE_DIR: '$CI_PROJECT_DIR/.terraform.d/plugin-cache'
  TF_CLI_CONFIG_FILE: '$CI_PROJECT_DIR/.slurm.tfrc'
  # Некоторые сторонние переменные требующие настройки
  GL_ASDF_TFLINT_VERSION: 0.42.2
  GL_ASDF_TERRAFORM_VERSION: 1.3.6
# Определение основных стадий
stages:
  - prepare
  - lint
  - validate
  - test
  - terratest
  - tftest
  - plan
  - apply
  - release
# Мы также включаем полезные шаблоны из GitLab для анализа нашего кода
include:
  # Проверяет ваш код на типичные ошибки
  - template: Security/SAST-IaC.gitlab-ci.yml
  # Проверяет что никакие секретные данные не попали в репозиторий
  - template: Security/Secret-Detection.gitlab-ci.yml
  # Запускает tflint и проверяет, что вы следуете Best Practices (от GitLab команды)
  - https://gitlab.com/gitlab-com/gl-infra/common-ci-tasks/-/raw/v1.56.2/tflint.yml
# Описываем конфигурацию для всех стадий с Terraform\Terragrunt
.terraform:
  image: cytopia/terragrunt:1.3-0.40
  before_script: &beforeTF
    - mkdir -p ${TF_PLUGIN_CACHE_DIR}
    - cat $TERRAFORMRC > ${TF_CLI_CONFIG_FILE}
  cache:
    - key: providers
      paths:
        - ${TF_PLUGIN_CACHE_DIR}
# Описываем наши задачи в CI\CD
## Инициализация Террагрант
Terragrunt:Init:
  extends: .terraform
  stage: prepare
  script: 
    - terraform --version
    - terragrunt --version
    - terragrunt run-all init -upgrade
  retry:
    max: 2
    when: script_failure
## Проверка формата Terraform кода
Terraform:Format:
  extends: .terraform
  stage: lint
  script: terraform fmt -recursive -check -diff
  rules: &prRules
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
## Проверка формата Terragrunt\HCL кода
Terragrunt:Format:
  extends: .terraform
  stage: lint
  script: terragrunt hclfmt --terragrunt-check
  rules: *prRules
## Запуск сканера Checkov
Lint:Checkov:
  stage: lint
  image:
    name: bridgecrew/checkov:2.2.299
    entrypoint:
      - '/usr/bin/env'
      - 'PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'
  rules:
    - if: $CI_COMMIT_BRANCH
      exists:
        - '**/*.yml'
        - '**/*.yaml'
        - '**/*.tf'      
  script: checkov -d .
  rules: *prRules
## Запуск валидации кода Terraform
Terragrunt:Validate:
  extends: .terraform
  stage: validate
  script: terragrunt run-all validate
  rules: *prRules
# Тесты
Test:Terratest:
  extends: .terraform
  stage: terratest
  script:
    - apk add --no-cache gcc libc-dev bind-tools make musl-dev go
    - go mod tidy
    - cd tests
    - go get github.com/gruntwork-io/terratest/modules/terraform
    - go test -timeout 0
  rules: *prRules
Test:TFTest:
  extends: .terraform
  stage: tftest
  script:
    - apk add python3
    - python3 -m venv .venv
    - source .venv/bin/activate
    - pip install -r requirements.txt
    - python3 -m pytest -vv
  rules: *prRules
## Выполнение Terragrunt plan на Stage
Staging:Plan:
  extends: .terraform
  stage: plan
  rules:
    - if: $STAGING_PLAN == "true"
    - if: $STAGING_APPLY == "true"
  script:
    - cd stage
    - terragrunt run-all plan -out=plan.json
  artifacts:
    paths:
      - stage/**/plan.json
    expire_in: 1 week
## Выполнение Terragrunt apply на Stage
Staging:Apply:
  extends: .terraform
  stage: apply
  environment:
    name: staging
  dependencies:
    - Staging:Plan
  rules:
    - if: $STAGING_APPLY == "true"
      when: manual
    - when: never
  script:
    - cd stage
    # Иногда использования плана может не работать, поэтому у нас есть такой вот fallback
    - terragrunt run-all --terragrunt-non-interactive apply -auto-approve plan.json || terragrunt run-all --terragrunt-non-interactive apply -auto-approve 
## Выполнение Terragrunt plan на Prod
Production:Plan:
  extends: .terraform
  stage: plan
  rules:
    - if: $PRODUCTION_PLAN == "true"
    - if: $PRODUCTION_APPLY == "true"
  script:
    - cd prod
    - terragrunt run-all plan -out=plan.json
  artifacts:
    paths:
      - stage/**/plan.json
    expire_in: 1 week
## Выполнение Terragrunt apply на Prod
Production:Apply:
  extends: .terraform
  environment:
    name: production
  stage: apply
  dependencies:
    - Production:Plan
  rules:
    - if: $PRODUCTION_APPLY == "true"
      when: manual
    - when: never
  script:
    - cd prod
    # Иногда использования плана может не работать, поэтому у нас есть такой вот fallback
    - terragrunt run-all --terragrunt-non-interactive apply -auto-approve plan.json || terragrunt run-all --terragrunt-non-interactive apply -auto-approve 
## Создание Git Tag
Release:Tag:
  stage: release
  image: registry.gitlab.com/juhani/go-semrel-gitlab:v0.21.1
  script: release --bump-patch tag
  rules:
    # We run release creation from default branch only
    - if: '$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH && $CI_PIPELINE_SOURCE == "push"'
# Модификация includes
tflint:
  stage: lint
  before_script: *beforeTF
  rules: *prRules
iac-sast:
  stage: lint
  rules: *prRules
kics-iac-sast:
  stage: lint
  rules: *prRules
secret_detection:
  stage: lint
  rules: *prRules
